<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>מערכת תכנון משימה - DTM Edition</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <!-- SunCalc -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.9.0/suncalc.min.js"></script>

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Heebo:wght@300;400;700;900&display=swap" rel="stylesheet">

    <style>
        html, body, #root { height: 100%; margin: 0; overflow: hidden; } 
        body { font-family: 'Heebo', sans-serif; background-color: #f8fafc; color: #0f172a; }
        
        #map { height: 100%; width: 100%; z-index: 0; }
        .leaflet-control-layers { border-radius: 8px !important; border: none !important; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1) !important; }
        
        .input-field { @apply w-full p-2 border border-slate-300 rounded-lg text-sm focus:ring-2 focus:ring-blue-600 focus:outline-none bg-white text-slate-800; }
        .btn-primary { @apply bg-slate-900 text-white py-2 px-4 rounded-lg font-bold text-sm hover:bg-slate-800 transition shadow-lg flex items-center justify-center gap-2; }
        
        /* Custom Scrollbar */
        .custom-scroll::-webkit-scrollbar { width: 4px; }
        .custom-scroll::-webkit-scrollbar-track { background: transparent; }
        .custom-scroll::-webkit-scrollbar-thumb { background-color: #94a3b8; border-radius: 10px; }

        /* Mobile Fixes */
        @media (max-width: 768px) {
            .mobile-panel { max-height: 45vh; }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;

        // --- Expanded Drone Database ---
        const DRONE_PRESETS = {
            // DJI Enterprise
            'matrice_350_p1': { name: 'DJI Matrice 350 RTK (P1)', sensorWidth: 35.9, focalLength: 35, imageWidth: 8192, type: 'Survey Full Frame' },
            'matrice_30_t': { name: 'DJI Matrice 30T', sensorWidth: 6.4, focalLength: 9.1, imageWidth: 4000, type: 'Inspection/Thermal' },
            'mavic_3_e': { name: 'DJI Mavic 3 Enterprise', sensorWidth: 17.3, focalLength: 12.29, imageWidth: 5280, type: 'Mapping' },
            'mavic_3_t': { name: 'DJI Mavic 3 Thermal', sensorWidth: 6.4, focalLength: 4.5, imageWidth: 4000, type: 'Thermal' },
            'mavic_3_m': { name: 'DJI Mavic 3 Multispectral', sensorWidth: 17.3, focalLength: 12.29, imageWidth: 5280, type: 'Agriculture' },
            'phantom_4_rtk': { name: 'DJI Phantom 4 RTK', sensorWidth: 13.2, focalLength: 8.8, imageWidth: 5472, type: 'Survey Legacy' },
            
            // DJI Consumer
            'mavic_3_pro': { name: 'DJI Mavic 3 Pro', sensorWidth: 17.3, focalLength: 12.29, imageWidth: 5280, type: 'Cinema' },
            'air_3': { name: 'DJI Air 3', sensorWidth: 9.6, focalLength: 6.72, imageWidth: 8064, type: 'Consumer' },
            'mini_3_pro': { name: 'DJI Mini 3 Pro', sensorWidth: 9.6, focalLength: 6.72, imageWidth: 8064, type: 'Compact' },
            'mini_4_pro': { name: 'DJI Mini 4 Pro', sensorWidth: 9.6, focalLength: 6.72, imageWidth: 8064, type: 'Compact' },

            // Autel Robotics
            'evo_max_4t': { name: 'Autel Evo Max 4T', sensorWidth: 12.8, focalLength: 8.5, imageWidth: 8192, type: 'Enterprise' },
            'evo_ii_pro_v3': { name: 'Autel Evo II Pro V3', sensorWidth: 13.2, focalLength: 10.5, imageWidth: 5472, type: 'Mapping' },
            'evo_ii_dual_640t': { name: 'Autel Evo II Dual 640T', sensorWidth: 9.8, focalLength: 6, imageWidth: 4000, type: 'Thermal' },
            
            // Others
            'skydio_x2': { name: 'Skydio X2', sensorWidth: 6.17, focalLength: 4.5, imageWidth: 4056, type: 'Autonomous' },
            'parrot_anafi_ai': { name: 'Parrot Anafi AI', sensorWidth: 23.5, focalLength: 23, imageWidth: 8000, type: 'Survey' }
        };

        // --- Icons ---
        const Icon = ({ name, size = 18, className = "" }) => {
            const icons = {
                map: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" /></svg>,
                mountain: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6" /></svg>,
                layers: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" /></svg>,
                drone: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" /></svg>,
                sun: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" /></svg>,
                trash: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>,
                gps: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" /></svg>,
                cloud: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M3 15a4 4 0 004 4h9a5 5 0 10-.1-9.999 5.002 5.002 0 10-9.78 2.096A4.001 4.001 0 003 15z" /></svg>,
                check: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M5 13l4 4L19 7" /></svg>
            };
            return icons[name] || null;
        };

        const App = () => {
            // State
            const [missionName, setMissionName] = useState('משימה חדשה');
            const [mapCenter, setMapCenter] = useState([32.0853, 34.7818]); // Default: Tel Aviv
            const [polygon, setPolygon] = useState([]);
            
            // Flight
            const [selectedDrone, setSelectedDrone] = useState('mavic_3_e');
            const [altitude, setAltitude] = useState(60);
            const [overlapFront, setOverlapFront] = useState(75);
            const [overlapSide, setOverlapSide] = useState(70);
            const [azimuth, setAzimuth] = useState(0);
            
            // Initialize date as local ISO string to match input type="datetime-local"
            const [flightDate, setFlightDate] = useState(() => {
                const now = new Date();
                const offsetMs = now.getTimezoneOffset() * 60000;
                return new Date(now.getTime() - offsetMs).toISOString().slice(0, 16);
            });

            // DTM & Shadows
            const [useDTM, setUseDTM] = useState(false);
            const [isFetchingDTM, setIsFetchingDTM] = useState(false);
            const [dtmData, setDtmData] = useState(null); // Array of {lat, lng, ele}
            const [dtmStats, setDtmStats] = useState(null);
            const [terrainShadows, setTerrainShadows] = useState([]); // Polygons for shadows

            // Weather
            const [weather, setWeather] = useState(null);
            const [isLoadingWeather, setIsLoadingWeather] = useState(false);
            const [weatherMessage, setWeatherMessage] = useState("");

            // Refs
            const mapRef = useRef(null);
            const layersRef = useRef({});

            // --- 1. Geolocation ---
            const locateUser = useCallback(() => {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        (pos) => {
                            const { latitude, longitude } = pos.coords;
                            setMapCenter([latitude, longitude]);
                            if (mapRef.current) mapRef.current.setView([latitude, longitude], 17);
                        },
                        (err) => {
                            let msg = "";
                            switch(err.code) {
                                case 1: msg = "המשתמש סירב לגישה למיקום."; break;
                                case 2: msg = "מיקום לא זמין."; break;
                                case 3: msg = "תם הזמן לאיתור מיקום."; break;
                                default: msg = "שגיאה לא ידועה באיתור מיקום.";
                            }
                            console.warn("GPS Notice:", msg);
                        },
                        { enableHighAccuracy: true, timeout: 10000 }
                    );
                } else {
                    console.warn("GPS not supported by browser.");
                }
            }, []);

            useEffect(() => locateUser(), [locateUser]);

            // --- 2. Fetch Weather (Forecast by Date) ---
            const fetchWeather = useCallback(async () => {
                if (!mapCenter) return;
                setIsLoadingWeather(true);
                setWeather(null);
                setWeatherMessage("");

                try {
                    const [lat, lng] = mapCenter;
                    // Fetch hourly forecast
                    const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&hourly=temperature_2m,rain,showers,cloud_cover,wind_speed_10m,wind_gusts_10m&timezone=auto`;
                    
                    const res = await fetch(url);
                    const data = await res.json();
                    
                    // Find index matching flightDate
                    // flightDate is "YYYY-MM-DDTHH:MM"
                    // API hourly time is "YYYY-MM-DDTHH:00"
                    const targetTimeStr = flightDate.slice(0, 13) + ":00";
                    
                    const index = data.hourly.time.findIndex(t => t === targetTimeStr);
                    
                    if (index !== -1) {
                        setWeather({
                            wind: data.hourly.wind_speed_10m[index],
                            gusts: data.hourly.wind_gusts_10m[index],
                            clouds: data.hourly.cloud_cover[index],
                            rain: (data.hourly.rain[index] + data.hourly.showers[index]), 
                            temp: data.hourly.temperature_2m[index],
                            time: targetTimeStr.replace('T', ' ')
                        });
                    } else {
                        setWeatherMessage("התאריך הנבחר מחוץ לטווח התחזית (7 ימים)");
                    }
                } catch (e) {
                    console.error("Weather Error", e);
                    setWeatherMessage("שגיאה בטעינת מזג אוויר");
                } finally {
                    setIsLoadingWeather(false);
                }
            }, [mapCenter, flightDate]);

            // Auto fetch weather on location or date change
            useEffect(() => { fetchWeather(); }, [fetchWeather]);

            // --- 3. Fetch DTM (Elevation) ---
            const fetchDTM = async () => {
                if (polygon.length < 3) return alert("יש לסמן אזור (פוליגון) קודם");
                setIsFetchingDTM(true);
                setDtmStats(null);
                setDtmData(null);
                setTerrainShadows([]);

                // Generate Grid Points within Polygon bounds
                const bounds = L.latLngBounds(polygon);
                const southWest = bounds.getSouthWest();
                const northEast = bounds.getNorthEast();
                
                // Create a coarse grid (e.g., 15x15 points for demo)
                const rows = 15, cols = 15;
                const latStep = (northEast.lat - southWest.lat) / rows;
                const lngStep = (northEast.lng - southWest.lng) / cols;
                
                let locations = [];
                for(let r=0; r<=rows; r++) {
                    for(let c=0; c<=cols; c++) {
                        locations.push({
                            lat: southWest.lat + r * latStep,
                            lng: southWest.lng + c * lngStep
                        });
                    }
                }

                // API Request string
                const locString = locations.map(p => `${p.lat.toFixed(5)},${p.lng.toFixed(5)}`).join('|');
                
                try {
                    // Using OpenTopoData (aster30m is global)
                    const url = `https://api.opentopodata.org/v1/aster30m?locations=${locString}`;
                    const res = await fetch(url);
                    
                    if (!res.ok) throw new Error(`API returned status ${res.status}`);
                    
                    const data = await res.json();
                    
                    if(data.results) {
                        const elevationGrid = data.results.map(r => ({
                            lat: r.location.lat,
                            lng: r.location.lng,
                            ele: r.elevation !== null ? r.elevation : 0 // Handle nulls
                        }));
                        
                        // Calculate Stats
                        const eles = elevationGrid.map(p => p.ele);
                        const min = Math.min(...eles);
                        const max = Math.max(...eles);
                        const avg = eles.reduce((a,b) => a+b, 0) / eles.length;
                        
                        setDtmStats({ min, max, avg });
                        setDtmData(elevationGrid);
                        calculateTerrainShadows(elevationGrid);
                    }
                } catch (e) {
                    alert("שגיאה בטעינת נתוני גובה (DTM). נסה שוב מאוחר יותר.");
                    console.error("DTM Fetch Error:", e);
                } finally {
                    setIsFetchingDTM(false);
                }
            };

            // --- 4. Calculate Terrain Shadows ---
            const calculateTerrainShadows = (elevationPoints) => {
                if (typeof SunCalc === 'undefined') {
                    console.warn("SunCalc ספריית לא נטענה, מדלג על חישוב צל.");
                    return;
                }

                // 1. Sun Position based on selected Flight Date
                const center = mapCenter;
                const sunPos = SunCalc.getPosition(new Date(flightDate), center[0], center[1]);
                const sunAzimuth = (sunPos.azimuth * 180 / Math.PI) + 180;
                const sunAltitude = sunPos.altitude * 180 / Math.PI; // degrees

                if (sunAltitude <= 0) return; // Night

                const shadows = [];
                
                elevationPoints.forEach(point => {
                    // Calculate shadow length based on elevation relative to "ground" (simplified)
                    // Just projecting the point to visualize relief direction
                    const shadowLenMeters = (point.ele * 0.5) * (1 / Math.tan(sunPos.altitude)); 
                    
                    const displayLen = Math.min(shadowLenMeters, 300); 

                    if (displayLen > 5) {
                        const shadowAzRad = ((sunAzimuth + 180) % 360) * (Math.PI / 180);
                        
                        const latOffset = (displayLen / 111111) * Math.cos(shadowAzRad);
                        const lngOffset = (displayLen / (111111 * Math.cos(point.lat * Math.PI/180))) * Math.sin(shadowAzRad);
                        
                        shadows.push([
                            [point.lat, point.lng],
                            [point.lat + latOffset, point.lng + lngOffset]
                        ]);
                    }
                });
                setTerrainShadows(shadows);
            };

            // Recalculate shadows when time changes (if DTM is loaded)
            useEffect(() => {
                if (dtmData) calculateTerrainShadows(dtmData);
            }, [flightDate]);

            // --- Map Init ---
            useEffect(() => {
                if (!mapRef.current) {
                    const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {attribution: 'OSM'});
                    const sat = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {attribution: 'Esri'});
                    
                    mapRef.current = L.map('map', {
                        center: mapCenter, // Use initialized center
                        zoom: 13,
                        layers: [sat] // Default Satellite
                    });
                    
                    L.control.layers({"לווין": sat, "מפה": osm}).addTo(mapRef.current);

                    mapRef.current.on('click', e => {
                        setPolygon(prev => [...prev, [e.latlng.lat, e.latlng.lng]]);
                    });
                }
            }, []);

            // --- Drawing Layers ---
            useEffect(() => {
                if (!mapRef.current) return;
                const map = mapRef.current;
                const L_refs = layersRef.current;

                // Clear old
                if (L_refs.poly) map.removeLayer(L_refs.poly);
                if (L_refs.path) map.removeLayer(L_refs.path);
                if (L_refs.shadows) map.removeLayer(L_refs.shadows);
                if (L_refs.heat) map.removeLayer(L_refs.heat);
                if (L_refs.markers) map.removeLayer(L_refs.markers);

                // Draw Polygon
                if (polygon.length > 0) {
                    L_refs.poly = L.polygon(polygon, {color: 'yellow', weight: 2, fillOpacity: 0.1}).addTo(map);
                }

                // Draw Path (Snake)
                if (polygon.length > 2) {
                    const drone = DRONE_PRESETS[selectedDrone];
                    const fp = (drone.sensorWidth * altitude) / drone.focalLength; // Approx
                    const spacing = fp * (1 - overlapSide/100);
                    
                    const bounds = L.latLngBounds(polygon);
                    const path = [];
                    let lat = bounds.getNorth();
                    const step = spacing / 111000;
                    let dir = 1;

                    while(lat > bounds.getSouth()) {
                        if(dir===1) {
                            path.push([lat, bounds.getWest()], [lat, bounds.getEast()]);
                        } else {
                            path.push([lat, bounds.getEast()], [lat, bounds.getWest()]);
                        }
                        lat -= step;
                        dir *= -1;
                    }
                    L_refs.path = L.polyline(path, {color: '#0ea5e9', weight: 2}).addTo(map);
                }

                // Draw DTM Shadows & Heatmap
                if (dtmData && terrainShadows.length > 0) {
                    // Shadows
                    L_refs.shadows = L.layerGroup(
                        terrainShadows.map(line => L.polyline(line, {color: 'black', weight: 4, opacity: 0.5}))
                    ).addTo(map);

                    // Elevation Points (Heatmap style)
                    const dots = dtmData.map(pt => {
                        // Simple color scale
                        const normalized = (pt.ele - dtmStats.min) / (dtmStats.max - dtmStats.min || 1);
                        const color = normalized > 0.5 ? '#ef4444' : '#22c55e'; 
                        return L.circleMarker([pt.lat, pt.lng], {radius: 2, color: color, fillOpacity: 0.6, stroke: false});
                    });
                    L_refs.heat = L.layerGroup(dots).addTo(map);
                }

                // Draw User Location
                if (mapCenter) {
                    const icon = L.divIcon({html: '<div class="w-4 h-4 bg-blue-500 rounded-full border-2 border-white shadow"></div>', className: 'bg-transparent'});
                    L_refs.markers = L.marker(mapCenter, {icon}).addTo(map);
                }

            }, [polygon, selectedDrone, altitude, overlapSide, terrainShadows, dtmData, mapCenter, useDTM]); // Added useDTM dependency implicitly via terrainShadows update

            // Stats
            const stats = useMemo(() => {
                const d = DRONE_PRESETS[selectedDrone];
                const gsd = (d.sensorWidth * altitude * 100) / (d.focalLength * d.imageWidth);
                return { gsd: gsd.toFixed(2) };
            }, [selectedDrone, altitude]);

            return (
                <div className="flex flex-col md:flex-row h-full">
                    
                    {/* Sidebar */}
                    <div className="w-full md:w-96 bg-slate-900 text-white flex flex-col z-20 shadow-2xl mobile-panel overflow-y-auto custom-scroll">
                        
                        <div className="p-4 bg-slate-800 border-b border-slate-700 sticky top-0 z-30 flex justify-between items-center">
                            <h1 className="font-black text-lg tracking-wider text-blue-400">DTM PLANNER</h1>
                            <button onClick={locateUser} className="bg-slate-700 p-2 rounded hover:bg-slate-600"><Icon name="gps" /></button>
                        </div>

                        <div className="p-4 space-y-6 flex-1">
                            
                            {/* Weather Dashboard (Updated) */}
                            <div className="bg-slate-800/80 rounded-lg p-3 border border-slate-700">
                                <h3 className="text-xs font-bold text-slate-400 mb-2 flex items-center gap-1"><Icon name="cloud"/> מזג אוויר (לפי זמן משימה)</h3>
                                {isLoadingWeather ? (
                                    <div className="text-center text-xs text-slate-500">טוען...</div>
                                ) : weather ? (
                                    <div>
                                        <div className="grid grid-cols-4 gap-2 text-center text-xs mb-2">
                                            <div className="bg-slate-700 p-1 rounded">
                                                <div className="font-bold text-blue-300">{weather.wind}</div>
                                                <div className="text-[9px] text-slate-400">קמ"ש רוח</div>
                                            </div>
                                            <div className="bg-slate-700 p-1 rounded">
                                                <div className="font-bold text-orange-300">{weather.gusts}</div>
                                                <div className="text-[9px] text-slate-400">משבים</div>
                                            </div>
                                            <div className="bg-slate-700 p-1 rounded">
                                                <div className="font-bold text-white">{weather.clouds}%</div>
                                                <div className="text-[9px] text-slate-400">עננות</div>
                                            </div>
                                            <div className="bg-slate-700 p-1 rounded">
                                                <div className="font-bold text-blue-400">{weather.rain.toFixed(1)}mm</div>
                                                <div className="text-[9px] text-slate-400">גשם</div>
                                            </div>
                                        </div>
                                        <div className="text-[9px] text-center text-slate-500">
                                            תחזית ל: {weather.time}
                                        </div>
                                    </div>
                                ) : (
                                    <div className="text-[10px] text-center text-red-400">{weatherMessage || "אין נתונים"}</div>
                                )}
                            </div>

                            {/* Drone & Flight */}
                            <div className="space-y-4">
                                <div>
                                    <label className="text-xs font-bold text-slate-400 block mb-1">רחפן</label>
                                    <select className="w-full bg-slate-800 border border-slate-600 rounded p-2 text-sm outline-none"
                                        value={selectedDrone} onChange={e=>setSelectedDrone(e.target.value)}>
                                        {Object.entries(DRONE_PRESETS).map(([k, v]) => <option key={k} value={k}>{v.name}</option>)}
                                    </select>
                                </div>

                                {/* SLIDERS */}
                                <div>
                                    <div className="flex justify-between text-xs mb-1">
                                        <span>גובה (AGL)</span>
                                        <span className="text-blue-400">{altitude}m</span>
                                    </div>
                                    <input type="range" min="20" max="200" value={altitude} onChange={e=>setAltitude(Number(e.target.value))} className="w-full accent-blue-500 h-1 bg-slate-600 rounded cursor-pointer"/>
                                </div>
                                <div>
                                    <div className="flex justify-between text-xs mb-1">
                                        <span>חפיפה קדמית</span>
                                        <span className="text-blue-400">{overlapFront}%</span>
                                    </div>
                                    <input type="range" min="10" max="90" value={overlapFront} onChange={e=>setOverlapFront(Number(e.target.value))} className="w-full accent-blue-500 h-1 bg-slate-600 rounded cursor-pointer"/>
                                </div>
                                <div>
                                    <div className="flex justify-between text-xs mb-1">
                                        <span>חפיפה צידית</span>
                                        <span className="text-blue-400">{overlapSide}%</span>
                                    </div>
                                    <input type="range" min="10" max="90" value={overlapSide} onChange={e=>setOverlapSide(Number(e.target.value))} className="w-full accent-blue-500 h-1 bg-slate-600 rounded cursor-pointer"/>
                                </div>
                            </div>

                            {/* DTM Section */}
                            <div className="pt-4 border-t border-slate-700">
                                <label className="text-xs font-bold text-slate-400 mb-2 block flex items-center gap-1">
                                    <Icon name="mountain"/> נתוני גובה וזמן
                                </label>
                                
                                <input 
                                    type="datetime-local" 
                                    value={flightDate} 
                                    onChange={e=>setFlightDate(e.target.value)}
                                    className="w-full bg-slate-800 border border-slate-600 rounded p-2 text-sm text-slate-300 text-center mb-3"
                                />

                                <button 
                                    onClick={fetchDTM}
                                    disabled={isFetchingDTM || polygon.length < 3}
                                    className={`w-full py-2 rounded text-sm font-bold mb-3 transition ${isFetchingDTM ? 'bg-slate-700 text-slate-500' : 'bg-blue-600 hover:bg-blue-500'}`}
                                >
                                    {isFetchingDTM ? 'טוען מהלווין...' : 'טען נתוני גובה וחשב צל'}
                                </button>

                                {/* DTM STATS INDICATOR */}
                                {dtmStats ? (
                                    <div className="bg-green-900/30 border border-green-700/50 p-3 rounded text-center animate-pulse">
                                        <div className="text-xs text-green-400 font-bold mb-1 flex items-center justify-center gap-1">
                                            <Icon name="check"/> נתונים נטענו בהצלחה (Aster 30m)
                                        </div>
                                        <div className="grid grid-cols-3 gap-1 text-[10px] text-green-200">
                                            <div>
                                                <span className="block font-bold text-white">{dtmStats.min.toFixed(0)}m</span>
                                                Min Elev
                                            </div>
                                            <div>
                                                <span className="block font-bold text-white">{dtmStats.avg.toFixed(0)}m</span>
                                                Avg Elev
                                            </div>
                                            <div>
                                                <span className="block font-bold text-white">{dtmStats.max.toFixed(0)}m</span>
                                                Max Elev
                                            </div>
                                        </div>
                                        <div className="text-[9px] mt-1 text-green-500/80">
                                            * צל מחושב לפי שעת הטיסה שנבחרה
                                        </div>
                                    </div>
                                ) : (
                                    <div className="text-[10px] text-center text-slate-500">
                                        שרטט פוליגון ולחץ לטעינת גבהים
                                    </div>
                                )}
                            </div>
                        </div>

                        <div className="p-4 bg-slate-800 border-t border-slate-700 flex gap-2">
                            <button onClick={()=>{setPolygon([]); setDtmData(null); setTerrainShadows([])}} className="p-2 bg-red-600/20 text-red-400 rounded hover:bg-red-600/40"><Icon name="trash"/></button>
                            <button className="flex-1 bg-blue-600 text-white rounded font-bold text-sm hover:bg-blue-500">שמור משימה</button>
                        </div>
                    </div>

                    {/* Map */}
                    <div className="flex-1 relative h-[45vh] md:h-full bg-black">
                        <div id="map"></div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
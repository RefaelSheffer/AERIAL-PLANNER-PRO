<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>מתכנן משימה - DTM יציב</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

    <!-- SunCalc -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.9.0/suncalc.min.js"></script>

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Heebo:wght@300;400;700;900&display=swap" rel="stylesheet">

    <style>
        html, body, #root { height: 100%; margin: 0; overflow: hidden; } 
        body { font-family: 'Heebo', sans-serif; background-color: #f8fafc; color: #0f172a; }
        
        #map { height: 100%; width: 100%; z-index: 0; }
        
        .input-field { @apply w-full p-2 border border-slate-300 rounded-lg text-sm focus:ring-2 focus:ring-blue-600 focus:outline-none bg-white text-slate-800; }
        
        /* Slider styling */
        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: #2563eb; cursor: pointer; margin-top: -6px; box-shadow: 0 1px 3px rgba(0,0,0,0.3); }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #cbd5e1; border-radius: 2px; }

        /* Custom Scrollbar */
        .custom-scroll::-webkit-scrollbar { width: 4px; }
        .custom-scroll::-webkit-scrollbar-track { background: transparent; }
        .custom-scroll::-webkit-scrollbar-thumb { background-color: #94a3b8; border-radius: 10px; }

        @media (max-width: 768px) { .mobile-panel { max-height: 55vh; } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- Drone Database ---
        const DRONE_PRESETS = {
            'matrice_30_t': { name: 'DJI Matrice 30T', sensorWidth: 6.4, sensorHeight: 4.8, focalLength: 9.1, imageWidth: 4000, type: 'Thermal' },
            'mavic_3_e': { name: 'DJI Mavic 3 Enterprise', sensorWidth: 17.3, sensorHeight: 13.0, focalLength: 12.29, imageWidth: 5280, type: 'Mapping' },
            'evo_ii_dual_640t': { name: 'Autel Evo II Dual 640T', sensorWidth: 9.8, sensorHeight: 7.3, focalLength: 6, imageWidth: 4000, type: 'Thermal' },
            'mavic_3_pro': { name: 'DJI Mavic 3 Pro', sensorWidth: 17.3, sensorHeight: 13.0, focalLength: 12.29, imageWidth: 5280, type: 'Cinema' },
        };

        // --- Icons ---
        const Icon = ({ name, size = 16 }) => {
            const icons = {
                map: <svg width={size} height={size} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7"/></svg>,
                mountain: <svg width={size} height={size} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6"/></svg>,
                wind: <svg width={size} height={size} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M17.657 18.657A8 8 0 016.343 7.343S7 9 9 10c0-2 .5-5 2.986-7C14 5 16.09 5.777 17.656 7.343A7.975 7.975 0 0120 13a7.975 7.975 0 01-2.343 5.657z"/><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9.879 16.121A3 3 0 1012.015 11L11 14H9c0 .768.293 1.536.879 2.121z"/></svg>,
                cloud: <svg width={size} height={size} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M3 15a4 4 0 004 4h9a5 5 0 10-.1-9.999 5.002 5.002 0 10-9.78 2.096A4.001 4.001 0 003 15z"/></svg>,
                gps: <svg width={size} height={size} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"/><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"/></svg>,
                trash: <svg width={size} height={size} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/></svg>,
                rotate: <svg width={size} height={size} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/></svg>,
                camera: <svg width={size} height={size} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z"/><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 13a3 3 0 11-6 0 3 3 0 016 0z"/></svg>,
                clock: <svg width={size} height={size} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>,
                warning: <svg width={size} height={size} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/></svg>
            };
            return icons[name] || null;
        };

        // --- Color Utils ---
        const windSpeedToColor = (speed) => {
            if (speed === null || speed === undefined || Number.isNaN(speed)) return '#cbd5e1';
            const clamped = Math.max(0, Math.min(speed, 25));
            // 0 m/s -> כחול, ~12 m/s -> ירוק, 25 m/s -> אדום
            const hue = 240 - (clamped / 25) * 240;
            return `hsl(${hue}, 85%, 55%)`;
        };

        const windTextColor = (speed) => {
            if (speed === null || speed === undefined || Number.isNaN(speed)) return 'text-slate-800';
            return speed >= 18 ? 'text-white' : 'text-slate-800';
        };

        // --- Geometry Utils ---
        const getDistance = (p1, p2) => {
            const R = 6371e3;
            const φ1 = p1.lat * Math.PI/180, φ2 = p2.lat * Math.PI/180;
            const Δφ = (p2.lat-p1.lat) * Math.PI/180, Δλ = (p2.lng-p1.lng) * Math.PI/180;
            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ/2) * Math.sin(Δλ/2);
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        };

        const getBearing = (p1, p2) => {
            const φ1 = p1.lat * Math.PI/180, φ2 = p2.lat * Math.PI/180;
            const Δλ = (p2.lng-p1.lng) * Math.PI/180;
            const y = Math.sin(Δλ) * Math.cos(φ2);
            const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
            return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
        };

        const getAutoAzimuth = (points) => {
            if(points.length < 2) return 0;
            let maxDist = 0;
            let bestBearing = 0;
            for(let i=0; i<points.length; i++) {
                const p1 = points[i];
                const p2 = points[(i+1)%points.length];
                const d = getDistance(p1, p2);
                if(d > maxDist) {
                    maxDist = d;
                    bestBearing = getBearing(p1, p2);
                }
            }
            return bestBearing;
        };

        const rotatePoint = (point, angleDeg, center) => {
            const angleRad = angleDeg * (Math.PI / 180);
            const cos = Math.cos(angleRad);
            const sin = Math.sin(angleRad);
            const dx = point.lng - center.lng;
            const dy = point.lat - center.lat;
            return {
                lat: center.lat + (dx * sin + dy * cos),
                lng: center.lng + (dx * cos - dy * sin)
            };
        };

        const unrotatePoint = (point, angleDeg, center) => {
            return rotatePoint(point, -angleDeg, center);
        };

        const App = () => {
            const [mapCenter, setMapCenter] = useState([32.0853, 34.7818]);
            const [polygon, setPolygon] = useState([]);
            
            // Flight Params
            const [selectedDrone, setSelectedDrone] = useState('mavic_3_e');
            const [altitude, setAltitude] = useState(60);
            const [overlapFront, setOverlapFront] = useState(75);
            const [overlapSide, setOverlapSide] = useState(70);
            const [speed, setSpeed] = useState(10); // m/s
            const [azimuth, setAzimuth] = useState(0);
            const [autoOrient, setAutoOrient] = useState(true);
            const [flightDate, setFlightDate] = useState(new Date().toISOString().slice(0, 16));

            // Stats
            const [totalDistance, setTotalDistance] = useState(0);

            // Weather & DTM
            const [hourlyForecast, setHourlyForecast] = useState(null);
            const [dtmData, setDtmData] = useState(null);
            const [isFetchingDTM, setIsFetchingDTM] = useState(false);
            const [dtmStats, setDtmStats] = useState(null);
            const [terrainShadows, setTerrainShadows] = useState([]);
            const [isSimulatedDTM, setIsSimulatedDTM] = useState(false); // New flag for fallback
            const [showTimeline, setShowTimeline] = useState(true);

            const mapRef = useRef(null);
            const layersRef = useRef({});

            // --- Geolocation ---
            useEffect(() => {
                navigator.geolocation.getCurrentPosition(
                    pos => {
                        setMapCenter([pos.coords.latitude, pos.coords.longitude]);
                        if(mapRef.current) mapRef.current.setView([pos.coords.latitude, pos.coords.longitude], 17);
                    },
                    err => console.warn("GPS Error:", err.code)
                );
            }, []);

            // --- Weather ---
            const fetchWeather = async () => {
                if(!mapCenter) return;
                try {
                    const [lat, lng] = mapCenter;
                    const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&hourly=temperature_2m,cloud_cover,wind_speed_10m,wind_gusts_10m,precipitation_probability&timezone=auto&forecast_days=7`;
                    const res = await fetch(url);
                    const data = await res.json();

                    if (data?.hourly) {
                        setHourlyForecast(data.hourly);
                    }
                } catch(e) { console.error(e); }
            };

            useEffect(() => { fetchWeather() }, [mapCenter]);

            const windTimeline = useMemo(() => {
                if(!hourlyForecast?.time) return [];
                const days = new Map();

                hourlyForecast.time.forEach((t, i) => {
                    const hour = Number(t.slice(11, 13));
                    if (hour % 3 !== 0) return; // רק כל 3 שעות

                    const dayKey = t.slice(0, 10);
                    if (!days.has(dayKey)) days.set(dayKey, { day: dayKey, slots: [] });

                    days.get(dayKey).slots.push({
                        key: t,
                        time: t.slice(11, 16),
                        wind: hourlyForecast.wind_speed_10m?.[i],
                        clouds: hourlyForecast.cloud_cover?.[i],
                        rainProb: hourlyForecast.precipitation_probability?.[i],
                        isMajor: hour % 6 === 0,
                    });
                });

                return Array.from(days.values()).map(day => ({
                    ...day,
                    label: new Date(day.day).toLocaleDateString('he-IL', { weekday: 'short', day: '2-digit', month: '2-digit' })
                }));
            }, [hourlyForecast]);

            // --- DTM (With Fallback) ---
            const fetchDTM = async () => {
                if (polygon.length < 3) return alert("סמן אזור תחילה");
                setIsFetchingDTM(true);
                setDtmData(null);
                setTerrainShadows([]);
                setIsSimulatedDTM(false);

                // Grid generation
                const latLngs = polygon.map(p => L.latLng(p.lat, p.lng));
                const bounds = L.latLngBounds(latLngs);
                const sw = bounds.getSouthWest(), ne = bounds.getNorthEast();
                
                const rows = 20, cols = 20; // Higher resolution
                let locations = [];
                for(let r=0; r<=rows; r++) {
                    for(let c=0; c<=cols; c++) {
                        locations.push({
                            lat: sw.lat + (ne.lat-sw.lat)*(r/rows),
                            lng: sw.lng + (ne.lng-sw.lng)*(c/cols)
                        });
                    }
                }
                
                try {
                    // Try Real API
                    const locStr = locations.map(p => `${p.lat.toFixed(5)},${p.lng.toFixed(5)}`).join('|');
                    const url = `https://api.opentopodata.org/v1/aster30m?locations=${locStr}`;
                    
                    // Create a promise that rejects if it takes too long (timeout)
                    const fetchPromise = fetch(url);
                    const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 5000));
                    
                    const res = await Promise.race([fetchPromise, timeoutPromise]);
                    
                    if (!res.ok) throw new Error('API Error');
                    const data = await res.json();
                    
                    if(data.results) {
                        const grid = data.results.map(r => ({lat: r.location.lat, lng: r.location.lng, ele: r.elevation || 0}));
                        processDTM(grid, false);
                    }
                } catch(e) {
                    console.warn("DTM API Failed, switching to simulation.", e);
                    // Fallback: Generate Simulated Terrain based on Perlin-like noise
                    const simGrid = locations.map((loc, i) => {
                        // Simple fake terrain: Base height + Math.sin waves
                        const baseEle = 100; 
                        const noise = Math.sin(loc.lat * 1000) * Math.cos(loc.lng * 1000) * 20;
                        return { lat: loc.lat, lng: loc.lng, ele: baseEle + noise };
                    });
                    processDTM(simGrid, true);
                } finally {
                    setIsFetchingDTM(false);
                }
            };

            const processDTM = (grid, isSim) => {
                setDtmData(grid);
                setIsSimulatedDTM(isSim);
                const eles = grid.map(p => p.ele);
                setDtmStats({min: Math.min(...eles), max: Math.max(...eles), avg: eles.reduce((a,b)=>a+b,0)/eles.length});
                calcShadows(grid);
            }

            const calcShadows = (grid) => {
                if(!SunCalc) return;
                const sun = SunCalc.getPosition(new Date(flightDate), mapCenter[0], mapCenter[1]);
                if(sun.altitude <= 0) return; // Night
                
                const shadows = [];
                const minEle = dtmStats ? dtmStats.min : Math.min(...grid.map(p=>p.ele));

                grid.forEach(pt => {
                    // Calculate shadow based on height relative to local minimum
                    const relativeHeight = pt.ele - minEle;
                    if (relativeHeight <= 1) return;

                    // Shadow Length = h / tan(alpha)
                    // Exaggerate slightly for visibility
                    const len = (relativeHeight * 1.2) / Math.tan(sun.altitude); 
                    
                    // Cap shadow length to avoid map artifacts
                    const displayLen = Math.min(len, 500); 

                    if (displayLen > 5) {
                        const az = sun.azimuth + Math.PI; 
                        const dLat = (Math.cos(az) * displayLen) / 111111;
                        const dLng = (Math.sin(az) * displayLen) / (111111 * Math.cos(pt.lat * Math.PI/180));
                        shadows.push([[pt.lat, pt.lng], [pt.lat+dLat, pt.lng+dLng]]);
                    }
                });
                setTerrainShadows(shadows);
            };

            useEffect(() => { if(dtmData) calcShadows(dtmData); }, [flightDate]);

            // --- Path Generation ---
            const generatePath = () => {
                if (polygon.length < 3) {
                    setTotalDistance(0);
                    return [];
                }

                const drone = DRONE_PRESETS[selectedDrone];
                const footprintW = (drone.sensorWidth * altitude) / drone.focalLength;
                const spacingMeters = footprintW * (1 - overlapSide/100);
                
                let angle = azimuth;
                const polyPoints = polygon.map(p => ({lat: p.lat, lng: p.lng}));

                if (autoOrient) {
                    angle = getAutoAzimuth(polyPoints);
                }

                const center = polyPoints[0]; 
                const rotatedPoly = polyPoints.map(p => rotatePoint(p, -angle, center));

                const lats = rotatedPoly.map(p => p.lat);
                const minLat = Math.min(...lats);
                const maxLat = Math.max(...lats);

                const spacingDeg = spacingMeters / 111111; 
                const lines = [];
                
                for (let y = maxLat - spacingDeg/2; y > minLat; y -= spacingDeg) {
                    let intersections = [];
                    for (let i = 0; i < rotatedPoly.length; i++) {
                        const p1 = rotatedPoly[i];
                        const p2 = rotatedPoly[(i + 1) % rotatedPoly.length];
                        if ((p1.lat > y && p2.lat <= y) || (p2.lat > y && p1.lat <= y)) {
                            const x = p1.lng + (y - p1.lat) * (p2.lng - p1.lng) / (p2.lat - p1.lat);
                            intersections.push(x);
                        }
                    }
                    intersections.sort((a, b) => a - b);
                    for (let i = 0; i < intersections.length; i += 2) {
                        if (i + 1 < intersections.length) {
                            lines.push([{ lat: y, lng: intersections[i] }, { lat: y, lng: intersections[i+1] }]);
                        }
                    }
                }

                const finalPath = [];
                let dist = 0;

                lines.forEach((line, index) => {
                    const start = unrotatePoint(line[0], -angle, center);
                    const end = unrotatePoint(line[1], -angle, center);
                    
                    dist += getDistance(start, end);

                    if (index > 0) {
                        const prevPoint = finalPath[finalPath.length - 1];
                        const currentStart = (index % 2 === 0) ? start : end;
                        dist += getDistance({lat: prevPoint[0], lng: prevPoint[1]}, currentStart);
                    }

                    if (index % 2 === 0) {
                        finalPath.push([start.lat, start.lng], [end.lat, end.lng]);
                    } else {
                        finalPath.push([end.lat, end.lng], [start.lat, start.lng]);
                    }
                });

                setTotalDistance(dist);
                return finalPath;
            };

            useEffect(() => {
                if(autoOrient && polygon.length > 2) {
                    const best = getAutoAzimuth(polygon.map(p => ({lat: p.lat, lng: p.lng})));
                    setAzimuth(Math.round(best));
                }
            }, [polygon, autoOrient]);

            // --- Map Rendering ---
            useEffect(() => {
                if (!mapRef.current) {
                    const esriImagery = L.tileLayer(
                        'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                        { attribution: 'Esri' }
                    );

                    const osmFallback = L.tileLayer(
                        'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                        { attribution: '&copy; OpenStreetMap contributors' }
                    );

                    // If the Esri imagery fails (rate limit / CORS), fall back to OpenStreetMap so the map still renders.
                    esriImagery.on('tileerror', () => {
                        if (!mapRef.current.hasLayer(osmFallback)) {
                            mapRef.current.addLayer(osmFallback);
                        }
                    });

                    mapRef.current = L.map('map', { center: mapCenter, zoom: 15, layers: [esriImagery], zoomControl: false });
                    mapRef.current.on('click', e => setPolygon(prev => [...prev, {lat: e.latlng.lat, lng: e.latlng.lng}]));
                }
            }, []);

            useEffect(() => {
                if (!mapRef.current) return;
                const map = mapRef.current;
                const Lr = layersRef.current;

                if (Lr.poly) map.removeLayer(Lr.poly);
                if (Lr.path) map.removeLayer(Lr.path);
                if (Lr.shadows) map.removeLayer(Lr.shadows);
                if (Lr.heat) map.removeLayer(Lr.heat);

                if (polygon.length > 0) {
                    const latLngs = polygon.map(p => [p.lat, p.lng]);
                    Lr.poly = L.polygon(latLngs, {color: 'yellow', weight: 2, fillOpacity: 0.1}).addTo(map);
                }

                if (polygon.length > 2) {
                    const pathPoints = generatePath();
                    Lr.path = L.polyline(pathPoints, {color: '#3b82f6', weight: 3}).addTo(map);
                }

                if (terrainShadows.length > 0) {
                    // Draw Shadows
                    Lr.shadows = L.layerGroup(terrainShadows.map(l => L.polyline(l, {color: 'black', weight: 4, opacity: 0.6}))).addTo(map);
                }
                
                if (dtmData) {
                    // Draw Heatmap Points
                    const dots = dtmData.map(pt => {
                        const normalized = (pt.ele - dtmStats.min) / (dtmStats.max - dtmStats.min || 1);
                        // Color scale: Green (Low) -> Red (High)
                        const color = `hsl(${120 - normalized * 120}, 100%, 50%)`; 
                        return L.circleMarker([pt.lat, pt.lng], {radius: 3, color: color, fillOpacity: 0.8, stroke: false});
                    });
                    Lr.heat = L.layerGroup(dots).addTo(map);
                }

            }, [polygon, selectedDrone, altitude, overlapSide, azimuth, autoOrient, terrainShadows, dtmData, speed]);

            // Stats Calc
            const stats = useMemo(() => {
                const d = DRONE_PRESETS[selectedDrone];
                const gsd = (d.sensorWidth * altitude * 100) / (d.focalLength * d.imageWidth);
                const timeMin = totalDistance > 0 ? Math.ceil((totalDistance / speed) / 60) : 0;
                const footprintH = (d.sensorHeight * altitude) / d.focalLength;
                const triggerDist = footprintH * (1 - overlapFront/100);
                const imgCount = totalDistance > 0 ? Math.ceil(totalDistance / triggerDist) : 0;

                return { gsd: gsd.toFixed(2), time: timeMin, images: imgCount, dist: Math.round(totalDistance) };
            }, [selectedDrone, altitude, totalDistance, speed, overlapFront]);

            const selectedSlotKey = useMemo(() => `${flightDate.slice(0, 13)}:00`, [flightDate]);

            return (
                <div className="flex flex-col md:flex-row h-full">
                    {/* Controls Sidebar */}
                    <div className="w-full md:w-96 bg-slate-900 text-white flex flex-col z-20 shadow-2xl mobile-panel overflow-y-auto custom-scroll">
                        
                        <div className="p-4 bg-slate-800 border-b border-slate-700 sticky top-0 z-30 flex justify-between items-center">
                            <h1 className="font-black text-lg tracking-wider text-blue-400">SMART PLANNER</h1>
                            <button className="bg-slate-700 p-2 rounded hover:bg-slate-600"><Icon name="gps"/></button>
                        </div>

                        <div className="p-4 space-y-6 flex-1">
                            {/* Flight Params */}
                            <div className="space-y-4">
                                <select className="input-field" value={selectedDrone} onChange={e=>setSelectedDrone(e.target.value)}>
                                    {Object.entries(DRONE_PRESETS).map(([k, v]) => <option key={k} value={k}>{v.name}</option>)}
                                </select>

                                {/* Sliders */}
                                <div>
                                    <div className="flex justify-between text-xs mb-1"><span>גובה (AGL)</span><span className="text-blue-400">{altitude}m</span></div>
                                    <input type="range" min="20" max="200" value={altitude} onChange={e=>setAltitude(Number(e.target.value))} className="w-full"/>
                                </div>
                                <div>
                                    <div className="flex justify-between text-xs mb-1"><span>מהירות טיסה</span><span className="text-blue-400">{speed} מ/ש</span></div>
                                    <input type="range" min="2" max="15" value={speed} onChange={e=>setSpeed(Number(e.target.value))} className="w-full"/>
                                </div>
                                <div>
                                    <div className="flex justify-between text-xs mb-1"><span>חפיפה קדמית</span><span className="text-blue-400">{overlapFront}%</span></div>
                                    <input type="range" min="10" max="90" value={overlapFront} onChange={e=>setOverlapFront(Number(e.target.value))} className="w-full"/>
                                </div>
                                <div>
                                    <div className="flex justify-between text-xs mb-1"><span>חפיפה צידית</span><span className="text-blue-400">{overlapSide}%</span></div>
                                    <input type="range" min="10" max="90" value={overlapSide} onChange={e=>setOverlapSide(Number(e.target.value))} className="w-full"/>
                                </div>

                                {/* Azimuth Control */}
                                <div className="bg-slate-800 p-2 rounded border border-slate-700">
                                    <div className="flex justify-between items-center mb-2">
                                        <span className="text-xs font-bold text-slate-400 flex items-center gap-1"><Icon name="rotate"/> כיוון טיסה</span>
                                        <label className="text-[10px] flex items-center gap-1 cursor-pointer">
                                            <input type="checkbox" checked={autoOrient} onChange={e=>setAutoOrient(e.target.checked)}/> אוטומטי
                                        </label>
                                    </div>
                                    <input type="range" min="0" max="360" value={azimuth} disabled={autoOrient} 
                                        onChange={e=>{setAzimuth(Number(e.target.value)); setAutoOrient(false);}} 
                                        className={`w-full ${autoOrient ? 'opacity-50 cursor-not-allowed' : ''}`}
                                    />
                                </div>
                            </div>

                            {/* DTM */}
                            <div className="pt-4 border-t border-slate-700">
                                <input type="datetime-local" value={flightDate} onChange={e=>setFlightDate(e.target.value)} className="input-field text-center mb-2"/>
                                <button onClick={fetchDTM} disabled={isFetchingDTM || polygon.length<3} className="w-full btn-primary bg-blue-600 hover:bg-blue-500">
                                    {isFetchingDTM ? 'טוען גבהים...' : 'טען DTM וחשב צל'}
                                </button>
                                {dtmStats && (
                                    <div className={`mt-2 text-[10px] text-center p-2 rounded border ${isSimulatedDTM ? 'bg-yellow-900/30 border-yellow-700 text-yellow-400' : 'bg-green-900/30 border-green-700 text-green-400'}`}>
                                        {isSimulatedDTM && <div className="flex justify-center items-center gap-1 mb-1 font-bold"><Icon name="warning"/> סימולציית שטח (Offline Mode)</div>}
                                        גבהים: {dtmStats.min.toFixed(0)}m - {dtmStats.max.toFixed(0)}m
                                    </div>
                                )}
                            </div>
                        </div>
                        
                        {/* BOTTOM STATS BAR */}
                        <div className="p-3 bg-slate-800 border-t border-slate-700 grid grid-cols-4 gap-2 text-center">
                            <div className="bg-slate-700/50 p-1 rounded">
                                <div className="text-[9px] text-slate-400">מרחק</div>
                                <div className="font-bold text-sm text-white">{stats.dist}m</div>
                            </div>
                            <div className="bg-slate-700/50 p-1 rounded">
                                <div className="text-[9px] text-slate-400">זמן (דק')</div>
                                <div className="font-bold text-sm text-blue-400"><Icon name="clock" size={10} className="inline mr-1"/>{stats.time}</div>
                            </div>
                            <div className="bg-slate-700/50 p-1 rounded">
                                <div className="text-[9px] text-slate-400">תמונות</div>
                                <div className="font-bold text-sm text-purple-400"><Icon name="camera" size={10} className="inline mr-1"/>{stats.images}</div>
                            </div>
                            <div className="bg-slate-700/50 p-1 rounded">
                                <div className="text-[9px] text-slate-400">GSD</div>
                                <div className="font-bold text-sm text-white">{stats.gsd}</div>
                            </div>
                        </div>
                    </div>

                    {/* Map */}
                    <div className="flex-1 relative h-[45vh] md:h-full bg-black">
                        <div id="map"></div>
                        <button onClick={()=>{setPolygon([]); setDtmData(null); setTotalDistance(0)}} className="absolute top-4 right-4 z-[1000] bg-red-600 text-white p-2 rounded shadow hover:bg-red-700"><Icon name="trash"/></button>
                        {polygon.length===0 && <div className="absolute top-4 left-1/2 -translate-x-1/2 bg-black/60 text-white px-4 py-2 rounded-full text-xs pointer-events-none z-[1000]">לחץ במפה לסימון</div>}
                        {/* Heatmap Legend */}
                        {dtmData && (
                            <div className="absolute bottom-6 left-6 z-[1000] bg-white/90 p-2 rounded text-xs shadow-lg text-slate-900">
                                <div className="font-bold mb-1">גבהים</div>
                                <div className="flex items-center gap-1">
                                    <div className="w-3 h-3 bg-red-500 rounded-full"></div> גבוה
                                </div>
                                <div className="flex items-center gap-1">
                                    <div className="w-3 h-3 bg-green-500 rounded-full"></div> נמוך
                                </div>
                                <div className="flex items-center gap-1 mt-1 border-t pt-1">
                                    <div className="w-4 h-1 bg-black/60"></div> צל
                                </div>
                            </div>
                        )}

                        {/* Wind & Clouds Timeline */}
                        <div className="absolute bottom-3 left-3 right-3 z-[1000] flex flex-col gap-2 pointer-events-none">
                            <div className="flex justify-end pointer-events-auto">
                                <button
                                    onClick={() => setShowTimeline(v => !v)}
                                    className="bg-white/90 text-slate-800 text-xs font-semibold px-3 py-2 rounded-full shadow border border-slate-200 hover:bg-white"
                                >
                                    {showTimeline ? 'הסתר לוח רוח/עננות/גשם' : 'הצג לוח רוח/עננות/גשם'}
                                </button>
                            </div>

                            {showTimeline && windTimeline.length > 0 && (
                                <div className="bg-white/95 backdrop-blur rounded-2xl border border-slate-200 shadow-2xl pointer-events-auto max-h-64 overflow-hidden">
                                    <div className="overflow-x-auto custom-scroll">
                                        <div className="flex gap-3 p-3 min-w-full">
                                            {windTimeline.map(day => (
                                                <div key={day.day} className="flex-shrink-0 w-56 bg-white border border-slate-200 rounded-xl shadow-sm p-2">
                                                    <div className="flex items-center justify-between mb-2">
                                                        <div className="text-xs font-bold text-slate-800">{day.label}</div>
                                                        <div className="text-[9px] text-slate-500">{day.slots.length} נקודות</div>
                                                    </div>
                                                    <div className="flex flex-wrap gap-1 justify-start">
                                                        {day.slots.map(slot => {
                                                            const slotKey = `${day.day}T${slot.time}`;
                                                            const isActive = slotKey === selectedSlotKey;
                                                            return (
                                                                <button
                                                                    key={slot.key}
                                                                onClick={() => setFlightDate(`${day.day}T${slot.time}`)}
                                                                    className={`w-16 h-20 flex flex-col items-center justify-between rounded-lg border transition shadow-sm hover:-translate-y-0.5 relative ${isActive ? 'border-blue-500 ring-2 ring-blue-200' : 'border-slate-200 hover:border-blue-300'}`}
                                                                    style={{ background: 'white' }}
                                                                >
                                                                    <div className="text-[9px] text-slate-500 pt-1">{slot.time}</div>
                                                                    <div
                                                                        className={`mx-1 h-8 w-[calc(100%-8px)] rounded-md flex items-center justify-center text-[10px] font-bold ${windTextColor(slot.wind)}`}
                                                                        style={{ background: windSpeedToColor(slot.wind) }}
                                                                    >
                                                                        {slot.wind?.toFixed(1) ?? '-'} מ"ש
                                                                        {slot.isMajor && <span className="absolute top-1 right-1 text-[8px] text-slate-100 bg-slate-900/50 px-1 rounded-full">6h</span>}
                                                                    </div>
                                                                    <div className="w-full px-2 pb-1">
                                                                        <div className="h-1.5 w-full bg-slate-200 rounded-full overflow-hidden">
                                                                            <div className="h-full bg-blue-500" style={{ width: `${slot.clouds ?? 0}%` }}></div>
                                                                        </div>
                                                                        <div className="text-[8px] text-center text-slate-500 mt-0.5 flex items-center justify-between px-1">
                                                                            <span>עננות {slot.clouds ?? 0}%</span>
                                                                            <span className="text-blue-700 font-semibold">גשם {slot.rainProb ?? 0}%</span>
                                                                        </div>
                                                                    </div>
                                                                </button>
                                                            );
                                                        })}
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>